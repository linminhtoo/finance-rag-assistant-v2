<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Financial RAG</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --border: rgba(255,255,255,0.12);
      --accent: #7c3aed;
      --accent2: #22c55e;
      --danger: #ef4444;
      --shadow: 0 18px 45px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(124,58,237,0.28), transparent 55%),
        radial-gradient(1100px 650px at 80% 20%, rgba(34,197,94,0.22), transparent 55%),
        radial-gradient(900px 500px at 50% 90%, rgba(59,130,246,0.20), transparent 55%),
        var(--bg);
      color: var(--text);
    }
    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(14px);
      background: linear-gradient(to bottom, rgba(11,16,32,0.92), rgba(11,16,32,0.65));
      border-bottom: 1px solid var(--border);
    }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 1rem 1.25rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    .brand { display: flex; align-items: baseline; gap: 0.8rem; }
    h1 { margin: 0; font-size: 1.05rem; letter-spacing: 0.2px; }
    .subtitle { color: var(--muted); font-size: 0.9rem; }
    .actions { display:flex; gap: 0.5rem; align-items:center; flex-wrap: wrap; }
    main {
      max-width: 2300px;
      margin: 0 auto;
      padding: 1.25rem;
    }
    .grid {
      display: grid;
      grid-template-columns: clamp(280px, 22vw, 360px) 1fr;
      gap: 1rem;
      align-items: start;
    }
    @media (max-width: 1200px) {
      .grid { grid-template-columns: 1fr; }
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .panelHeader {
      padding: 0.9rem 1rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      background: rgba(255,255,255,0.03);
    }
    .panelHeader h2 { margin: 0; font-size: 0.95rem; }
    .panelBody { padding: 1rem; }
    .muted { color: var(--muted); }
    .row { display:flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }
    .spacer { flex: 1; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      outline: none;
    }
    textarea { min-height: 110px; resize: vertical; }
    input::placeholder, textarea::placeholder { color: rgba(255,255,255,0.45); }
    .btn {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 0.55rem 0.8rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }
    .btn.primary { background: linear-gradient(135deg, rgba(124,58,237,0.95), rgba(59,130,246,0.85)); border-color: rgba(124,58,237,0.25); }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.danger { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.35); }
    .btn.danger:hover { background: rgba(239,68,68,0.18); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .pill {
      font-size: 0.78rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      white-space: nowrap;
    }
    .historyList { max-height: 70vh; overflow: auto; }
    .historyItem {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
    }
    .historyItem:hover { background: rgba(255,255,255,0.06); }
    .historyItem.active { background: rgba(124,58,237,0.14); }
    .historyQ { font-weight: 650; font-size: 0.92rem; line-height: 1.25rem; }
    .historyMeta { margin-top: 0.3rem; font-size: 0.82rem; color: var(--muted); display:flex; gap: 0.5rem; flex-wrap: wrap; }
    .statusLine { font-size: 0.9rem; color: var(--muted); }
    .answer {
      white-space: pre-wrap;
      line-height: 1.45rem;
      font-size: 0.98rem;
    }
    .markdown p { margin: 0.55rem 0; }
    .markdown h1, .markdown h2, .markdown h3, .markdown h4, .markdown h5, .markdown h6 { margin: 0.8rem 0 0.4rem 0; }
    .markdown h1 { font-size: 1.25rem; }
    .markdown h2 { font-size: 1.15rem; }
    .markdown h3 { font-size: 1.05rem; }
    .markdown code { font-family: var(--mono); font-size: 0.9em; padding: 0.08rem 0.28rem; border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; background: rgba(0,0,0,0.25); }
    .markdown pre { font-family: var(--mono); font-size: 0.86rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.10); border-radius: 12px; padding: 0.75rem; overflow: auto; }
    .markdown ul { margin: 0.5rem 0 0.5rem 1.25rem; }
    mark { background: rgba(34,197,94,0.22); color: var(--text); padding: 0.02rem 0.12rem; border-radius: 6px; }
    mark.active { outline: 2px solid rgba(34,197,94,0.85); background: rgba(34,197,94,0.30); }
    details {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      overflow: hidden;
    }
    summary {
      list-style: none;
      cursor: pointer;
      padding: 0.7rem 0.85rem;
      display:flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: space-between;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }
    .chunkBody { padding: 0.85rem; border-top: 1px solid var(--border); }
    .chunkText {
      font-family: var(--mono);
      font-size: 0.86rem;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 0.75rem;
      overflow: auto;
      white-space: pre-wrap;
    }
    a { color: rgba(147,197,253,0.95); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .kv { display:grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    @media (max-width: 980px) { .kv { grid-template-columns: 1fr; } }
    .help {
      font-size: 0.86rem;
      color: var(--muted);
      line-height: 1.2rem;
    }
    .code { font-family: var(--mono); font-size: 0.86rem; }
    .qaSplit {
      display: flex;
      gap: 0;
      align-items: stretch;
      min-width: 0;
      --sourcesPaneWidth: 900px;
    }
    .qaMain {
      flex: 1 1 auto;
      min-width: 0;
      padding-right: 1rem;
    }
    .qaSplitter {
      flex: 0 0 14px;
      cursor: col-resize;
      position: relative;
      touch-action: none;
      user-select: none;
    }
    .qaSplitter::before {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      background: rgba(255,255,255,0.16);
    }
    .qaSplitter:hover::before { background: rgba(124,58,237,0.65); }
    .qaSplitter:focus-visible { outline: 2px solid rgba(124,58,237,0.85); outline-offset: -3px; }
    .qaSources {
      flex: 0 0 var(--sourcesPaneWidth);
      min-width: 320px;
      max-width: 70%;
      min-height: 0;
      padding-left: 1rem;
    }
    body.resizing {
      cursor: col-resize;
      user-select: none;
    }
	    @media (min-width: 981px) {
	      #askPanel .panelBody { height: calc(100vh - 170px); overflow: hidden; }
	      #askPanel .qaSplit { height: 100%; }
	      #askPanel .qaMain { display: flex; flex-direction: column; min-height: 0; overflow: hidden; }
	      #askPanel #answerBlock { flex: 1 1 auto; min-height: 0; overflow: auto; padding-right: 0.5rem; }
	      #askPanel .qaSources { min-height: 0; display: flex; flex-direction: column; overflow: auto; }
	      #askPanel .qaSources details { min-height: 0; }
	      #askPanel .qaSources details[open] { height: 100%; flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; }
	      #askPanel .qaSources details[open] .chunkBody { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; overflow: auto; }
	      #askPanel #sourceContent { flex: 1 1 auto; min-height: 0; overflow: auto; }
	    }
    @media (max-width: 980px) {
      .qaSplit { flex-direction: column; }
      .qaMain { padding-right: 0; }
      .qaSplitter { display: none; }
      .qaSources { flex: 0 0 auto; min-width: 0; max-width: none; width: 100%; padding-left: 0; margin-top: 1rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">
        <h1>Financial RAG</h1>
        <div class="subtitle">Ask questions, inspect retrieved chunks, and open source docs.</div>
      </div>
      <div class="actions">
        <span class="pill" id="healthPill">checking /health…</span>
        <button class="btn" id="reloadHistoryBtn" title="Reload persisted history">Reload history</button>
        <button class="btn" id="exportHistoryBtn" title="Download history as JSON">Export</button>
        <button class="btn danger" id="clearHistoryBtn" title="Delete persisted server history">Clear history</button>
      </div>
    </div>
  </header>
  <main>
    <div class="grid">
      <section class="panel">
        <div class="panelHeader">
          <h2>History</h2>
          <span class="pill" id="historyCount">0</span>
        </div>
        <div class="panelBody" style="padding-bottom: 0.75rem;">
          <input id="historyFilter" type="text" placeholder="Filter by question text…" />
          <div class="help" style="margin-top: 0.6rem;">
            Persisted on the server at <span class="code" id="historyPath">(loading…)</span> and also cached in your browser.
          </div>
        </div>
        <div class="historyList" id="historyList"></div>
      </section>

      <section class="panel" id="askPanel">
        <div class="panelHeader">
          <h2>Ask</h2>
          <div class="row">
            <span class="pill" id="activeEntryPill">no selection</span>
          </div>
        </div>
        <div class="panelBody">
          <div class="qaSplit" id="qaSplit">
            <div class="qaMain">
	              <form id="queryForm" style="margin-top: 1rem;">
	                <label class="muted" for="question">Question</label>
	                <textarea id="question" name="question" placeholder="e.g. Summarize the key risk factors mentioned in the latest filing for Company X."></textarea>

                  <div style="margin-top: 0.75rem;">
                    <div class="kv">
                      <div>
                        <label class="muted" for="genMode">Mode</label>
                        <select id="genMode"></select>
                        <div class="help" id="genModeHelp" style="margin-top: 0.35rem;"></div>
                      </div>
                    </div>
                  </div>

	                <details style="margin-top: 0.75rem;">
	                  <summary>
	                    <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
	                      <strong>Advanced options</strong>
	                      <span class="pill">top_k, max_tokens</span>
	                    </div>
	                    <div class="muted" style="font-size: 0.86rem;">toggle</div>
	                  </summary>
	                  <div class="chunkBody">
	                    <div class="kv">
	                      <div>
	                        <label class="muted" for="topKRetrieve">top_k_retrieve</label>
	                        <input id="topKRetrieve" type="number" min="1" step="1" value="30" />
	                      </div>
	                      <div>
	                        <label class="muted" for="topKRerank">top_k_rerank</label>
	                        <input id="topKRerank" type="number" min="1" step="1" value="8" />
	                      </div>
	                      <div>
	                        <label class="muted" for="draftMaxTokens">draft_max_tokens</label>
	                        <input id="draftMaxTokens" type="number" min="1" step="1" value="65536" />
	                      </div>
	                      <div>
	                        <label class="muted" for="finalMaxTokens">final_max_tokens</label>
	                        <input id="finalMaxTokens" type="number" min="1" step="1" value="32768" />
	                      </div>
	                    </div>
	                  </div>
	                </details>

                <div class="row" style="margin-top: 0.85rem;">
                  <button class="btn primary" type="submit" id="queryBtn">Ask</button>
                  <button class="btn danger" type="button" id="stopBtn" disabled>Stop</button>
                  <button class="btn" type="button" id="copyAnswerBtn" disabled>Copy answer</button>
                  <button class="btn" type="button" id="copyDebugBtn" disabled>Copy debug</button>
                  <div class="spacer"></div>
                  <span class="statusLine" id="queryStatus"></span>
                </div>
              </form>

              <div id="answerBlock" style="display:none; margin-top: 1rem;">
                <div class="row" style="margin-bottom: 0.25rem;">
                  <h3 style="margin: 0; font-size: 1rem;">Progress</h3>
                  <div class="spacer"></div>
                  <span class="pill" id="requestIdPill">idle</span>
                </div>
                <div class="chunkText" id="progressLog" style="max-height: 18vh; margin-bottom: 0.9rem;"></div>

                <details id="draftDetails" style="margin-bottom: 0.9rem;">
                  <summary>
                    <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
                      <strong>Draft</strong>
                      <span class="pill" id="draftStatePill">waiting</span>
                    </div>
                    <div class="muted" style="font-size: 0.86rem;">toggle</div>
                  </summary>
                  <div class="chunkBody">
                    <div class="answer markdown" id="draftAnswer"></div>
                  </div>
                </details>

                <div class="row" style="margin-bottom: 0.25rem;">
                  <h3 style="margin: 0; font-size: 1rem;">Final answer</h3>
                  <div class="spacer"></div>
                  <span class="pill" id="chunkCountPill">0 chunks</span>
                </div>
                <div class="answer markdown" id="finalAnswer"></div>

	                <div style="margin-top: 1rem;">
	                  <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Reranked chunks (used for answer)</h3>
	                  <div class="help" style="margin-bottom: 0.6rem;">
	                    Use “Open source” to view the underlying PDF/Markdown. For local paths outside the allowlist, set
	                    <span class="code">SOURCE_ROOTS</span> on the server.
	                  </div>
	                  <div id="chunks"></div>

	                  <details id="retrievedDetails" style="margin-top: 0.9rem;">
	                    <summary>
	                      <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
	                        <strong>Retrieved (pre-rerank)</strong>
	                        <span class="pill" id="retrievedCountPill">0</span>
	                      </div>
	                      <div class="muted" style="font-size: 0.86rem;">toggle</div>
	                    </summary>
	                    <div class="chunkBody">
	                      <div id="retrievedChunks"></div>
	                    </div>
	                  </details>
	                </div>
	              </div>
            </div>

            <div class="qaSplitter" id="qaSplitter" role="separator" aria-orientation="vertical" aria-label="Resize source viewer" tabindex="0"></div>

            <aside class="qaSources" id="qaSources">
              <details id="sourceViewerDetails" open>
                <summary>
                  <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
                    <strong>Source viewer</strong>
                    <span class="pill" id="sourceCountPill">0 docs</span>
                    <span class="pill" id="sourceModePill">raw</span>
                  </div>
                  <div class="muted" style="font-size: 0.86rem;">toggle</div>
                </summary>
                <div class="chunkBody">
                  <div class="row" style="margin-bottom:0.6rem;">
                    <select id="sourceSelect" style="flex:1; min-width: 260px;"></select>
                    <button class="btn" type="button" id="sourceReloadBtn">Reload</button>
                    <button class="btn" type="button" id="sourceToggleModeBtn">Toggle rendered/raw</button>
                    <div class="spacer"></div>
                    <span class="statusLine" id="sourceStatus"></span>
                  </div>
                  <div class="help" id="sourceMeta" style="margin-bottom:0.6rem;"></div>
                  <div class="chunkText" id="sourceContent" style="max-height: 70vh;"></div>
                </div>
              </details>
            </aside>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    const els = {
      healthPill: $('healthPill'),
      reloadHistoryBtn: $('reloadHistoryBtn'),
      exportHistoryBtn: $('exportHistoryBtn'),
      clearHistoryBtn: $('clearHistoryBtn'),
      historyCount: $('historyCount'),
      historyPath: $('historyPath'),
      historyFilter: $('historyFilter'),
      historyList: $('historyList'),
      activeEntryPill: $('activeEntryPill'),

      queryForm: $('queryForm'),
      question: $('question'),
      genMode: $('genMode'),
      genModeHelp: $('genModeHelp'),
      topKRetrieve: $('topKRetrieve'),
      topKRerank: $('topKRerank'),
      draftMaxTokens: $('draftMaxTokens'),
      finalMaxTokens: $('finalMaxTokens'),
      queryBtn: $('queryBtn'),
      stopBtn: $('stopBtn'),
      queryStatus: $('queryStatus'),

      answerBlock: $('answerBlock'),
      requestIdPill: $('requestIdPill'),
      progressLog: $('progressLog'),
      draftDetails: $('draftDetails'),
      draftStatePill: $('draftStatePill'),
      draftAnswer: $('draftAnswer'),
      finalAnswer: $('finalAnswer'),
      retrievedDetails: $('retrievedDetails'),
      retrievedCountPill: $('retrievedCountPill'),
      retrievedChunks: $('retrievedChunks'),
      chunks: $('chunks'),
      chunkCountPill: $('chunkCountPill'),

      copyAnswerBtn: $('copyAnswerBtn'),
      copyDebugBtn: $('copyDebugBtn'),

      sourceViewerDetails: $('sourceViewerDetails'),
      sourceCountPill: $('sourceCountPill'),
      sourceModePill: $('sourceModePill'),
      sourceSelect: $('sourceSelect'),
      sourceReloadBtn: $('sourceReloadBtn'),
      sourceToggleModeBtn: $('sourceToggleModeBtn'),
      sourceStatus: $('sourceStatus'),
      sourceContent: $('sourceContent'),
      sourceMeta: $('sourceMeta'),

      qaSplit: $('qaSplit'),
      qaSplitter: $('qaSplitter'),
      qaSources: $('qaSources'),
    };

    const LS_HISTORY = 'finrag_history_v1';
    const LS_SETTINGS = 'finrag_settings_v1';
    const LS_UI = 'finrag_ui_v1';
    const DEFAULT_SOURCES_PANE_WIDTH_PX = 620;

    let generationDefaultMode = 'normal';
    let generationPresets = [];
    let generationPresetByKey = new Map(); // key -> preset

    let historyItems = [];
    let activeEntry = null;
    let lastQueryResponse = null;
    let sourceMode = 'raw'; // 'raw' or 'rendered'
    let lastChunksBySource = new Map(); // source -> chunks[]
    let sourceCache = new Map(); // source -> {path, text}

    function safeText(s) {
      return String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function setGenerationPresets(payload) {
      const presets = Array.isArray(payload?.presets) ? payload.presets : [];
      generationDefaultMode = String(payload?.default_mode || 'normal').trim().toLowerCase() || 'normal';
      generationPresets = presets.filter(p => p && typeof p === 'object' && p.key);
      generationPresetByKey = new Map(generationPresets.map(p => [String(p.key).toLowerCase(), p]));
    }

    async function loadGenerationPresets() {
      try {
        const res = await fetch('/generation_presets');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        setGenerationPresets(data);
      } catch (e) {
        // Fallback if the backend endpoint isn't available (e.g., old server build).
        setGenerationPresets({
          default_mode: 'normal',
          presets: [
            { key: 'quick', label: 'Quick', description: 'Fast + concise. Skips reranking and verification.', top_k_retrieve: 12, top_k_rerank: 6, draft_max_tokens: 16384, final_max_tokens: 16384 },
            { key: 'normal', label: 'Normal', description: 'Balanced quality/speed. Uses reranking + verification.', top_k_retrieve: 30, top_k_rerank: 8, draft_max_tokens: 65536, final_max_tokens: 32768 },
            { key: 'thinking', label: 'Thinking', description: 'Higher recall + deeper report. Retrieves/reranks more and verifies.', top_k_retrieve: 40, top_k_rerank: 12, draft_max_tokens: 65536, final_max_tokens: 45000 },
          ],
        });
      }
    }

    function populateModeSelect() {
      if (!els.genMode) return;
      els.genMode.innerHTML = '';
      generationPresets.forEach((p) => {
        const opt = document.createElement('option');
        opt.value = String(p.key || '');
        opt.textContent = String(p.label || p.key || '');
        els.genMode.appendChild(opt);
      });
    }

    function updateModeHelp(key) {
      const p = generationPresetByKey.get(String(key || '').toLowerCase());
      if (!els.genModeHelp) return;
      if (!p) {
        els.genModeHelp.textContent = '';
        return;
      }
      els.genModeHelp.textContent = String(p.description || '');
    }

    function applyModePreset(key, { overwriteAdvanced = true } = {}) {
      const p = generationPresetByKey.get(String(key || '').toLowerCase());
      if (!p) return;
      if (overwriteAdvanced) {
        if (p.top_k_retrieve) els.topKRetrieve.value = p.top_k_retrieve;
        if (p.top_k_rerank) els.topKRerank.value = p.top_k_rerank;
        if (p.draft_max_tokens) els.draftMaxTokens.value = p.draft_max_tokens;
        if (p.final_max_tokens) els.finalMaxTokens.value = p.final_max_tokens;
      }
      updateModeHelp(key);
    }

    function extractDocMeta(chunk) {
      const meta = chunk?.metadata;
      if (!meta || typeof meta !== 'object') return null;
      const doc = meta.doc;
      if (!doc || typeof doc !== 'object') return null;
      return doc;
    }

    function formatDocMetaLine(doc) {
      if (!doc || typeof doc !== 'object') return '';
      const bits = [];
      if (doc.company) bits.push(`Company: ${safeText(doc.company)}`);
      if (doc.ticker) bits.push(`Ticker: ${safeText(doc.ticker)}`);
      const filingBits = [];
      if (doc.filing_type) filingBits.push(safeText(doc.filing_type));
      if (doc.filing_date) filingBits.push(`filed ${safeText(doc.filing_date)}`);
      if (doc.period_end_date) filingBits.push(`period ended ${safeText(doc.period_end_date)}`);
      if (filingBits.length) bits.push(`Filing: ${filingBits.join(', ')}`);
      if (doc.filing_quarter) bits.push(`Quarter: ${safeText(doc.filing_quarter)}`);
      return bits.join(' • ');
    }

    function sanitizeHref(href) {
      const h = String(href || '').trim();
      if (!h) return '#';
      if (h.startsWith('http://') || h.startsWith('https://') || h.startsWith('/')) return h;
      return '#';
    }

    function mdInline(s) {
      // Input is raw text; returns safe HTML.
      let out = safeText(s);
      out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
      out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, href) => {
        const h = sanitizeHref(href);
        return `<a href="${h}" target="_blank" rel="noopener">${text}</a>`;
      });
      return out;
    }

    function renderMarkdown(md) {
      const lines = String(md ?? '').replace(/\r\n/g, '\n').split('\n');
      let html = '';
      let inCode = false;
      let inList = false;
      let codeBuf = '';
      const closeList = () => { if (inList) { html += '</ul>'; inList = false; } };
      const flushCode = () => {
        if (codeBuf) {
          html += `<pre><code>${safeText(codeBuf)}</code></pre>`;
          codeBuf = '';
        }
      };
      for (const line of lines) {
        const fence = line.match(/^```/);
        if (fence) {
          if (!inCode) {
            closeList();
            inCode = true;
            codeBuf = '';
          } else {
            inCode = false;
            flushCode();
          }
          continue;
        }
        if (inCode) {
          codeBuf += line + '\n';
          continue;
        }

        const heading = line.match(/^(#{1,6})\s+(.*)$/);
        if (heading) {
          closeList();
          const level = heading[1].length;
          html += `<h${level}>${mdInline(heading[2])}</h${level}>`;
          continue;
        }
        const li = line.match(/^\s*[-*]\s+(.*)$/);
        if (li) {
          if (!inList) { html += '<ul>'; inList = true; }
          html += `<li>${mdInline(li[1])}</li>`;
          continue;
        }

        if (!line.trim()) {
          closeList();
          html += '<br />';
          continue;
        }
        closeList();
        html += `<p>${mdInline(line)}</p>`;
      }
      if (inCode) flushCode();
      if (inList) html += '</ul>';
      return html;
    }

    function isMarkdownSource(source) {
      const s = String(source || '').trim().toLowerCase();
      return s.endsWith('.md') || s.endsWith('.markdown') || s.endsWith('.txt');
    }

    function buildChunksBySource(chunks) {
      const map = new Map();
      (Array.isArray(chunks) ? chunks : []).forEach((c) => {
        const src = String(c?.source || '').trim();
        if (!src) return;
        if (!map.has(src)) map.set(src, []);
        map.get(src).push(c);
      });
      return map;
    }

    function findBestSpan(text, snippet) {
      const hay = String(text ?? '');
      let needle = String(snippet ?? '').trim();
      if (!hay || !needle) return null;

      if (needle.length > 240) needle = needle.slice(0, 240);

      let idx = hay.indexOf(needle);
      if (idx >= 0) return { start: idx, end: idx + needle.length };

      // Try whitespace-insensitive match using a token regex.
      const tokens = needle.split(/\s+/).filter(Boolean).slice(0, 30);
      if (tokens.length >= 6) {
        const escapeRe = (t) => String(t).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const pattern = tokens.map(escapeRe).join('\\s+');
        const re = new RegExp(pattern, 'm');
        const m = re.exec(hay);
        if (m && typeof m.index === 'number') return { start: m.index, end: m.index + m[0].length };
      }

      // Fall back to searching a shorter prefix.
      if (needle.length > 80) {
        const short = needle.slice(0, 80);
        idx = hay.indexOf(short);
        if (idx >= 0) return { start: idx, end: idx + short.length };
      }

      return null;
    }

    function renderTextWithMarks(text, spans, activeChunkId) {
      const src = String(text ?? '');
      const safeSpans = (Array.isArray(spans) ? spans : [])
        .filter(s => s && Number.isFinite(s.start) && Number.isFinite(s.end) && s.start >= 0 && s.end > s.start)
        .sort((a, b) => a.start - b.start);

      const merged = [];
      let lastEnd = -1;
      for (const s of safeSpans) {
        if (s.start < lastEnd) continue;
        merged.push(s);
        lastEnd = s.end;
      }

      let out = '';
      let pos = 0;
      for (const s of merged) {
        out += safeText(src.slice(pos, s.start));
        const chunkId = String(s.chunk_id || '');
        const cls = chunkId && activeChunkId && chunkId === activeChunkId ? 'active' : '';
        out += `<mark class="${cls}" data-chunk-id="${safeText(chunkId)}">${safeText(src.slice(s.start, s.end))}</mark>`;
        pos = s.end;
      }
      out += safeText(src.slice(pos));
      return out;
    }

    async function loadSourceText(source) {
      const src = String(source || '').trim();
      if (!src) throw new Error('Missing source');
      if (sourceCache.has(src)) return sourceCache.get(src);
      const res = await fetch('/source_text?path=' + encodeURIComponent(src));
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      sourceCache.set(src, data);
      return data;
    }

    function populateSourceSelect() {
      const sources = Array.from(lastChunksBySource.keys()).filter(isMarkdownSource);
      const prev = String(els.sourceSelect.value || '').trim();
      els.sourceSelect.innerHTML = '';
      sources.forEach((src) => {
        const opt = document.createElement('option');
        const count = (lastChunksBySource.get(src) || []).length;
        opt.value = src;
        opt.textContent = `${src} (${count})`;
        els.sourceSelect.appendChild(opt);
      });
      els.sourceCountPill.textContent = `${sources.length} docs`;
      if (!sources.length) {
        els.sourceSelect.disabled = true;
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No markdown sources in current results';
        els.sourceSelect.appendChild(opt);
        renderSourceViewer('', null);
        return;
      }
      els.sourceSelect.disabled = false;
      const selected = sources.includes(prev) ? prev : sources[0];
      els.sourceSelect.value = selected;
      renderSourceViewer(selected, null);
    }

    async function renderSourceViewer(source, activeChunkId) {
      const src = String(source || '').trim();
      if (!src || !isMarkdownSource(src)) {
        els.sourceModePill.textContent = sourceMode;
        els.sourceStatus.textContent = '';
        if (els.sourceMeta) els.sourceMeta.innerHTML = '';
        els.sourceContent.innerHTML = '<div class="muted">Select a markdown source to view it here.</div>';
        return;
      }

      const chunksForSrc = lastChunksBySource.get(src) || [];
      const doc = extractDocMeta(chunksForSrc[0]);
      const docLine = formatDocMetaLine(doc);
      if (els.sourceMeta) els.sourceMeta.innerHTML = docLine ? docLine : '';

      els.sourceStatus.textContent = 'Loading…';
      try {
        const data = await loadSourceText(src);
        const text = String(data.text ?? '');
        const chunks = chunksForSrc;

        const spans = [];
        for (const c of chunks) {
          const chunkId = String(c?.chunk_id || '');
          const snippet = String(c?.text || c?.preview || '').trim();
          if (!chunkId || !snippet) continue;
          const span = findBestSpan(text, snippet);
          if (!span) continue;
          spans.push({ ...span, chunk_id: chunkId });
        }

        if (sourceMode === 'rendered') {
          els.sourceModePill.textContent = 'rendered';
          els.sourceContent.classList.add('markdown');
          els.sourceContent.innerHTML = renderMarkdown(text);
          els.sourceStatus.textContent = 'Rendered (highlighting is raw-only)';
        } else {
          els.sourceModePill.textContent = 'raw';
          els.sourceContent.classList.remove('markdown');
          els.sourceContent.innerHTML = renderTextWithMarks(text, spans, activeChunkId);
          els.sourceStatus.textContent = spans.length ? `Highlighted ${spans.length} matches` : 'No matches found';
          if (activeChunkId) {
            const m = els.sourceContent.querySelector(`mark[data-chunk-id="${CSS.escape(activeChunkId)}"]`);
            if (m) m.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        }
      } catch (e) {
        console.error(e);
        els.sourceStatus.textContent = 'Error';
        els.sourceContent.innerHTML = `<div class="muted">Failed to load source: ${safeText(e)}</div>`;
      }
    }

    function fmtDate(iso) {
      if (!iso) return 'unknown time';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return String(iso);
      return d.toLocaleString();
    }

    function readLocalHistory() {
      try {
        const raw = localStorage.getItem(LS_HISTORY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function writeLocalHistory(items) {
      try { localStorage.setItem(LS_HISTORY, JSON.stringify(items)); } catch {}
    }

    function readSettings() {
      try {
        const raw = localStorage.getItem(LS_SETTINGS);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function writeSettings(settings) {
      try { localStorage.setItem(LS_SETTINGS, JSON.stringify(settings)); } catch {}
    }

    function readUi() {
      try {
        const raw = localStorage.getItem(LS_UI);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function writeUi(patch) {
      try {
        const prev = readUi() || {};
        const next = { ...prev, ...(patch || {}) };
        localStorage.setItem(LS_UI, JSON.stringify(next));
      } catch {}
    }

    function clampSourcesPaneWidth(px) {
      const n = Number(px);
      if (!Number.isFinite(n)) return DEFAULT_SOURCES_PANE_WIDTH_PX;
      const rect = els.qaSplit?.getBoundingClientRect?.();
      const containerWidth = rect?.width || 0;
      const min = 320;
      const max = containerWidth ? Math.max(min, Math.floor(containerWidth * 0.7)) : 900;
      return Math.min(max, Math.max(min, Math.round(n)));
    }

    function setSourcesPaneWidth(px) {
      if (!els.qaSplit) return null;
      const w = clampSourcesPaneWidth(px);
      els.qaSplit.style.setProperty('--sourcesPaneWidth', `${w}px`);
      if (els.qaSplitter) {
        els.qaSplitter.setAttribute('aria-valuenow', String(w));
        els.qaSplitter.setAttribute('aria-valuemin', '320');
      }
      return w;
    }

    function applyUi(ui) {
      if (!els.qaSplit) return;
      const w = ui?.sourcesPaneWidthPx ?? ui?.sources_pane_width_px ?? null;
      const applied = setSourcesPaneWidth(Number(w) || DEFAULT_SOURCES_PANE_WIDTH_PX);
      if (els.qaSplitter && applied) {
        const rect = els.qaSplit.getBoundingClientRect();
        const max = rect?.width ? Math.max(320, Math.floor(rect.width * 0.7)) : 900;
        els.qaSplitter.setAttribute('aria-valuemax', String(max));
      }
    }

    function setupSourcesSplitter() {
      if (!els.qaSplit || !els.qaSplitter) return;

      let dragging = false;
      const raw = getComputedStyle(els.qaSplit).getPropertyValue('--sourcesPaneWidth').trim();
      const m = raw.match(/(\d+)\s*px/);
      const initial = m ? Number(m[1]) : DEFAULT_SOURCES_PANE_WIDTH_PX;
      let lastAppliedWidth = setSourcesPaneWidth(initial) || DEFAULT_SOURCES_PANE_WIDTH_PX;

      const applyFromPointer = (clientX) => {
        const rect = els.qaSplit.getBoundingClientRect();
        const raw = rect.right - clientX;
        const applied = setSourcesPaneWidth(raw);
        if (typeof applied === 'number') lastAppliedWidth = applied;
        els.qaSplitter.setAttribute('aria-valuemax', String(Math.max(320, Math.floor(rect.width * 0.7))));
      };

      const endDrag = () => {
        if (!dragging) return;
        dragging = false;
        document.body.classList.remove('resizing');
        writeUi({ sourcesPaneWidthPx: lastAppliedWidth });
      };

      els.qaSplitter.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return;
        dragging = true;
        document.body.classList.add('resizing');
        try { els.qaSplitter.setPointerCapture(e.pointerId); } catch {}
        applyFromPointer(e.clientX);
      });
      els.qaSplitter.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        applyFromPointer(e.clientX);
      });
      els.qaSplitter.addEventListener('pointerup', () => endDrag());
      els.qaSplitter.addEventListener('pointercancel', () => endDrag());
      els.qaSplitter.addEventListener('dblclick', () => {
        lastAppliedWidth = setSourcesPaneWidth(DEFAULT_SOURCES_PANE_WIDTH_PX) || DEFAULT_SOURCES_PANE_WIDTH_PX;
        writeUi({ sourcesPaneWidthPx: lastAppliedWidth });
      });
      els.qaSplitter.addEventListener('keydown', (e) => {
        const step = e.shiftKey ? 60 : 20;
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          lastAppliedWidth = setSourcesPaneWidth(lastAppliedWidth + step) || lastAppliedWidth;
          writeUi({ sourcesPaneWidthPx: lastAppliedWidth });
        }
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          lastAppliedWidth = setSourcesPaneWidth(lastAppliedWidth - step) || lastAppliedWidth;
          writeUi({ sourcesPaneWidthPx: lastAppliedWidth });
        }
      });

      window.addEventListener('resize', () => {
        lastAppliedWidth = setSourcesPaneWidth(lastAppliedWidth) || lastAppliedWidth;
      });
    }

    function currentSettings() {
      const toInt = (v, fallback) => {
        const n = Number(v);
        return Number.isFinite(n) && n > 0 ? Math.floor(n) : fallback;
      };
      const mode = String(els.genMode?.value || '').trim().toLowerCase() || generationDefaultMode || 'normal';
      return {
        mode,
        top_k_retrieve: toInt(els.topKRetrieve.value, 30),
        top_k_rerank: toInt(els.topKRerank.value, 8),
        draft_max_tokens: toInt(els.draftMaxTokens.value, 65536),
        final_max_tokens: toInt(els.finalMaxTokens.value, 32768),
      };
    }

    function applySettings(s) {
      if (!s) return;
      const mode = String(s.mode || s.generation_mode || '').trim().toLowerCase() || generationDefaultMode || 'normal';
      if (els.genMode) {
        els.genMode.value = generationPresetByKey.has(mode) ? mode : generationDefaultMode;
        updateModeHelp(els.genMode.value);
      }
      if (s.top_k_retrieve) els.topKRetrieve.value = s.top_k_retrieve;
      if (s.top_k_rerank) els.topKRerank.value = s.top_k_rerank;
      if (s.draft_max_tokens) els.draftMaxTokens.value = s.draft_max_tokens;
      if (s.final_max_tokens) els.finalMaxTokens.value = s.final_max_tokens;
    }

    async function checkHealth() {
      try {
        const res = await fetch('/health');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        els.healthPill.textContent = 'healthy';
        els.healthPill.style.borderColor = 'rgba(34,197,94,0.45)';
        els.healthPill.style.color = 'rgba(167,243,208,0.95)';
      } catch {
        els.healthPill.textContent = 'health check failed';
        els.healthPill.style.borderColor = 'rgba(239,68,68,0.45)';
        els.healthPill.style.color = 'rgba(254,202,202,0.95)';
      }
    }

    function renderHistory() {
      const q = (els.historyFilter.value || '').trim().toLowerCase();
      const filtered = q
        ? historyItems.filter(it => (it?.request?.question || '').toLowerCase().includes(q))
        : historyItems;

      els.historyCount.textContent = String(filtered.length);
      els.historyList.innerHTML = '';

      if (!filtered.length) {
        const div = document.createElement('div');
        div.className = 'panelBody muted';
        div.textContent = q ? 'No matches.' : 'No history yet. Ask a question to create entries.';
        els.historyList.appendChild(div);
        return;
      }

      filtered.forEach((it) => {
        const div = document.createElement('div');
        div.className = 'historyItem' + ((activeEntry && it.id === activeEntry.id) ? ' active' : '');
        const question = it?.request?.question || '(missing question)';
        const when = fmtDate(it?.created_at);
        const chunks = it?.response?.top_chunks?.length ?? 0;
        const mode = String(it?.request?.mode || '').trim().toLowerCase();
        div.innerHTML = `
          <div class="historyQ">${safeText(question)}</div>
          <div class="historyMeta">
            <span>${safeText(when)}</span>
            <span class="pill">${chunks} chunks</span>
            ${mode ? `<span class="pill">mode: ${safeText(mode)}</span>` : ``}
          </div>
        `;
        div.addEventListener('click', () => {
          activeEntry = it;
          els.activeEntryPill.textContent = it.id ? `selected: ${it.id.slice(0, 8)}` : 'selected';
          renderHistory();
          showEntry(it);
        });
        els.historyList.appendChild(div);
      });
    }

    function sourceHref(source) {
      const s = String(source || '').trim();
      if (!s) return null;
      if (s.startsWith('http://') || s.startsWith('https://')) return s;
      return '/source?path=' + encodeURIComponent(s);
    }

    function renderChunks(chunks, opts) {
      const container = opts?.container || els.chunks;
      const countPill = opts?.countPill || els.chunkCountPill;
      const list = Array.isArray(chunks) ? chunks : [];
      if (countPill) countPill.textContent = `${list.length} chunks`;
      container.innerHTML = '';
      if (!list.length) {
        container.innerHTML = '<div class="muted">No chunks returned.</div>';
        return;
      }

      list.forEach((c, idx) => {
        const headings = Array.isArray(c.headings) && c.headings.length ? c.headings.join(' › ') : '';
        const href = sourceHref(c.source);
        const score = (typeof c.score === 'number') ? c.score.toFixed(3) : String(c.score ?? '');
        const preview = safeText((c.preview ?? '') + (c.preview ? '…' : ''));
        const meta = (c && typeof c.metadata === 'object') ? c.metadata : null;
        const doc = extractDocMeta(c);
        const docLine = formatDocMetaLine(doc);
        const summary = (meta && typeof meta.summary === 'string') ? meta.summary.trim() : '';
        const chunkText = String(c.text ?? '');
        const contextText = String(c.context ?? '').trim();
        const src = String(c.source || '').trim();
        const canViewInApp = isMarkdownSource(src);

        const details = document.createElement('details');
        details.style.marginBottom = '0.6rem';
        details.innerHTML = `
	          <summary>
	            <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
	              <span class="pill">#${idx + 1}</span>
	              <span class="pill">score=${safeText(score)}</span>
	              <span class="pill">doc=${safeText(c.doc_id ?? '')}</span>
	              <span class="pill">chunk=${safeText(c.chunk_id ?? '')}</span>
	              ${doc?.company ? `<span class="pill">co=${safeText(doc.company)}</span>` : ''}
	              ${doc?.ticker ? `<span class="pill">ticker=${safeText(doc.ticker)}</span>` : ''}
	              ${doc?.filing_type ? `<span class="pill">${safeText(doc.filing_type)}</span>` : ''}
	              ${doc?.filing_date ? `<span class="pill">filed=${safeText(doc.filing_date)}</span>` : ''}
	            </div>
	            <div class="muted" style="font-size: 0.86rem;">toggle</div>
	          </summary>
          <div class="chunkBody">
            ${docLine ? `<div class="help" style="margin-bottom:0.35rem;">${docLine}</div>` : ''}
            ${headings ? `<div style="margin-bottom:0.35rem;"><strong>${safeText(headings)}</strong></div>` : ''}
            ${summary ? `<div class="muted" style="margin-bottom:0.35rem;">${safeText(summary)}</div>` : ''}
            <div class="muted" style="margin-bottom:0.55rem;">${preview}</div>
            <div class="row" style="margin-bottom: 0.6rem;">
              ${href ? `<a href="${href}" target="_blank" rel="noopener">Open source</a>` : '<span class="muted">No source link</span>'}
              <button class="btn" type="button" data-action="view-in-app" ${canViewInApp ? '' : 'disabled'}>View in app</button>
              <span class="pill">${canViewInApp ? 'markdown' : 'non-markdown'}</span>
            </div>
            ${contextText ? `<div style="margin-bottom:0.55rem;"><div class="muted" style="margin-bottom:0.2rem;">Context</div><div class="chunkText">${safeText(contextText)}</div></div>` : ''}
            ${chunkText ? `<div><div class="muted" style="margin-bottom:0.2rem;">Chunk text</div><div class="chunkText">${safeText(chunkText)}</div></div>` : '<div class="muted">No chunk text included.</div>'}
          </div>
        `;
        details.addEventListener('toggle', () => {
          if (details.open && canViewInApp) {
            // Mildly helpful: open the source viewer when you expand a chunk.
            els.sourceViewerDetails.open = true;
            els.sourceSelect.value = src;
            renderSourceViewer(src, String(c.chunk_id || ''));
          }
        });
        const btn = details.querySelector('button[data-action="view-in-app"]');
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            els.sourceViewerDetails.open = true;
            els.sourceSelect.value = src;
            renderSourceViewer(src, String(c.chunk_id || ''));
          });
        }
        container.appendChild(details);
      });
    }

    function showEntry(it) {
      if (!it) return;
      const res = it.response || {};
      els.answerBlock.style.display = 'block';
      els.requestIdPill.textContent = it.id ? ('hist ' + String(it.id).slice(0, 8)) : 'history';
      els.progressLog.textContent = '';
      els.draftStatePill.textContent = 'done';
      els.draftAnswer.innerHTML = renderMarkdown(String(res.draft_answer ?? ''));
      els.finalAnswer.innerHTML = renderMarkdown(String(res.final_answer ?? ''));
      const chunks = res.top_chunks || [];
      renderChunks(chunks);
      lastChunksBySource = buildChunksBySource(chunks);
      populateSourceSelect();
      lastQueryResponse = res;
      els.copyAnswerBtn.disabled = !String(res.final_answer ?? '').trim();
      els.copyDebugBtn.disabled = false;
    }

    async function loadHistoryFromServer() {
      const res = await fetch('/history?limit=200');
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      const items = Array.isArray(data.items) ? data.items : [];
      historyItems = items;
      if (data.path) els.historyPath.textContent = data.path;
      writeLocalHistory(items);
      renderHistory();
      return items;
    }

    async function loadHistory() {
      // Fast path: render local cache immediately, then refresh from server.
      historyItems = readLocalHistory();
      renderHistory();
      try {
        await loadHistoryFromServer();
      } catch (e) {
        console.warn('Failed to load /history; using local cache.', e);
      }
    }

    async function clearHistory() {
      if (!confirm('Delete server history? This removes the JSONL file.')) return;
      els.clearHistoryBtn.disabled = true;
      try {
        const res = await fetch('/history', { method: 'DELETE' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        historyItems = [];
        activeEntry = null;
        writeLocalHistory([]);
        renderHistory();
        els.activeEntryPill.textContent = 'no selection';
        els.answerBlock.style.display = 'none';
        lastChunksBySource = new Map();
        populateSourceSelect();
      } catch (e) {
        alert('Failed to clear history: ' + e);
      } finally {
        els.clearHistoryBtn.disabled = false;
      }
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function exportHistory() {
      try {
        const res = await fetch('/history?limit=2000');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const items = Array.isArray(data.items) ? data.items : [];
        downloadJson('finrag_history.json', items);
      } catch (e) {
        alert('Failed to export history: ' + e);
      }
    }

    let activeStream = null; // { controller, requestId }

    function appendProgress(line) {
      const prev = String(els.progressLog.textContent || '');
      const next = prev ? (prev + '\n' + String(line)) : String(line);
      els.progressLog.textContent = next;
      els.progressLog.scrollTop = els.progressLog.scrollHeight;
    }

    async function stopActiveQuery() {
      const stream = activeStream;
      if (!stream) return;
      try { stream.controller.abort(); } catch {}
      const rid = stream.requestId;
      if (rid) {
        fetch('/cancel', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ request_id: rid }),
        }).catch(() => {});
      }
      activeStream = null;
    }

    async function doQuery(question) {
      const settings = currentSettings();
      writeSettings(settings);

      els.queryBtn.disabled = true;
      els.stopBtn.disabled = false;
      els.queryStatus.textContent = 'Starting…';
      els.copyAnswerBtn.disabled = true;
      els.copyDebugBtn.disabled = true;

      els.answerBlock.style.display = 'block';
      els.requestIdPill.textContent = '…';
      els.progressLog.textContent = '';
      els.draftStatePill.textContent = 'waiting';
      els.draftAnswer.innerHTML = '';
      els.finalAnswer.innerHTML = '';
      els.retrievedCountPill.textContent = '0 chunks';
      els.retrievedChunks.innerHTML = '';
      renderChunks([], { container: els.chunks, countPill: els.chunkCountPill });
      lastChunksBySource = new Map();
      populateSourceSelect();

      let draftText = '';
      let finalText = '';
      let draftRenderTimer = null;
      let finalRenderTimer = null;
      let streamState = null;

      try {
        await stopActiveQuery();
        const controller = new AbortController();
        streamState = { controller, requestId: null };
        activeStream = streamState;

        const res = await fetch('/query_stream', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question, ...settings }),
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);

        const reader = res.body?.getReader();
        if (!reader) throw new Error('Missing response body');

        const decoder = new TextDecoder();
        let buf = '';
        const scheduleDraftRender = () => {
          if (draftRenderTimer) return;
          draftRenderTimer = setTimeout(() => {
            els.draftAnswer.innerHTML = renderMarkdown(draftText);
            draftRenderTimer = null;
          }, 120);
        };
        const scheduleFinalRender = () => {
          if (finalRenderTimer) return;
          finalRenderTimer = setTimeout(() => {
            els.finalAnswer.innerHTML = renderMarkdown(finalText);
            finalRenderTimer = null;
          }, 120);
        };

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });
          let idx;
          while ((idx = buf.indexOf('\n')) >= 0) {
            const line = buf.slice(0, idx);
            buf = buf.slice(idx + 1);
            if (!line.trim()) continue;
            let evt = null;
            try { evt = JSON.parse(line); } catch { continue; }

            const type = String(evt?.type || '');
            if (type === 'start') {
              streamState.requestId = String(evt?.request_id || '');
              els.requestIdPill.textContent = streamState.requestId ? ('req ' + streamState.requestId.slice(0, 8)) : 'req';
              appendProgress('Started ' + els.requestIdPill.textContent);
              continue;
            }

            if (type === 'status') {
              const msg = String(evt?.message || '');
              const step = String(evt?.step || '');
              els.queryStatus.textContent = msg || (step ? ('Step: ' + step) : '');
              appendProgress(step ? (step + ': ' + msg) : msg);
              if (step === 'draft') {
                els.draftStatePill.textContent = 'streaming';
                els.draftDetails.open = true;
              }
              continue;
            }

            if (type === 'retrieved') {
              const chunks = Array.isArray(evt?.chunks) ? evt.chunks : [];
              renderChunks(chunks, { container: els.retrievedChunks, countPill: els.retrievedCountPill });
              els.retrievedDetails.open = true;
              appendProgress('Retrieved ' + String(evt?.count ?? chunks.length) + ' chunks');
              continue;
            }

            if (type === 'reranked') {
              const chunks = Array.isArray(evt?.chunks) ? evt.chunks : [];
              renderChunks(chunks, { container: els.chunks, countPill: els.chunkCountPill });
              appendProgress('Reranked ' + String(evt?.count ?? chunks.length) + ' chunks');
              continue;
            }

            if (type === 'draft_delta') {
              const delta = String(evt?.delta || '');
              if (delta) {
                draftText += delta;
                els.draftDetails.open = true;
                scheduleDraftRender();
              }
              continue;
            }

            if (type === 'draft_done') {
              els.draftStatePill.textContent = 'done';
              appendProgress('Draft ready');
              continue;
            }

            if (type === 'final_delta') {
              const delta = String(evt?.delta || '');
              if (delta) {
                finalText += delta;
                scheduleFinalRender();
              }
              continue;
            }

            if (type === 'cancelled') {
              els.queryStatus.textContent = 'Cancelled.';
              appendProgress('Cancelled');
              break;
            }

            if (type === 'error') {
              const err = String(evt?.error || 'Unknown error');
              els.queryStatus.textContent = 'Error: ' + err;
              appendProgress('Error: ' + err);
              break;
            }

            if (type === 'done') {
              const data = evt?.response || {};
              lastQueryResponse = data;
              els.queryStatus.textContent = '';

              // Re-render with the final, full payload (includes full chunk text/context).
              els.draftStatePill.textContent = 'done';
              draftText = String(data.draft_answer ?? draftText);
              finalText = String(data.final_answer ?? finalText);
              els.draftAnswer.innerHTML = renderMarkdown(draftText);
              els.finalAnswer.innerHTML = renderMarkdown(finalText);

              const chunks = data.top_chunks || [];
              renderChunks(chunks, { container: els.chunks, countPill: els.chunkCountPill });
              lastChunksBySource = buildChunksBySource(chunks);
              populateSourceSelect();

              els.copyAnswerBtn.disabled = !String(finalText || '').trim();
              els.copyDebugBtn.disabled = false;

              // Refresh persisted history so the new entry shows up with its server timestamp/id.
              await loadHistoryFromServer();
              appendProgress('Done in ' + String(evt?.elapsed_ms ?? '') + 'ms');
              break;
            }
          }
        }
      } catch (e) {
        if (String(e?.name || '') === 'AbortError') {
          els.queryStatus.textContent = 'Cancelled.';
          appendProgress('Cancelled');
        } else {
          console.error(e);
          els.queryStatus.textContent = 'Error: ' + e;
          appendProgress('Error: ' + e);
        }
      } finally {
        els.queryBtn.disabled = false;
        els.stopBtn.disabled = true;
        if (streamState?.controller?.signal?.aborted) {
          // Keep the request id pill for debugging.
        } else {
          els.requestIdPill.textContent = streamState?.requestId ? ('req ' + streamState.requestId.slice(0, 8)) : 'idle';
        }
        if (activeStream === streamState) activeStream = null;
      }
    }

    els.queryForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const q = (els.question.value || '').trim();
      if (!q) {
        els.queryStatus.textContent = 'Please enter a question.';
        return;
      }
      await doQuery(q);
    });

    els.stopBtn.addEventListener('click', async () => {
      await stopActiveQuery();
    });

    els.historyFilter.addEventListener('input', () => renderHistory());
    els.reloadHistoryBtn.addEventListener('click', () => loadHistory());
    els.clearHistoryBtn.addEventListener('click', () => clearHistory());
    els.exportHistoryBtn.addEventListener('click', () => exportHistory());

    els.copyAnswerBtn.addEventListener('click', async () => {
      const text = String(lastQueryResponse?.final_answer ?? '');
      try { await navigator.clipboard.writeText(text); } catch { alert('Clipboard write failed'); }
    });

    els.copyDebugBtn.addEventListener('click', async () => {
      const payload = {
        question: String(els.question.value || ''),
        settings: currentSettings(),
        response: lastQueryResponse,
        selected_history_entry: activeEntry,
      };
      try { await navigator.clipboard.writeText(JSON.stringify(payload, null, 2)); } catch { alert('Clipboard write failed'); }
    });

    els.sourceSelect.addEventListener('change', async () => {
      await renderSourceViewer(els.sourceSelect.value, null);
    });
    els.sourceReloadBtn.addEventListener('click', async () => {
      const src = els.sourceSelect.value;
      sourceCache.delete(src);
      await renderSourceViewer(src, null);
    });
    els.sourceToggleModeBtn.addEventListener('click', async () => {
      sourceMode = (sourceMode === 'raw') ? 'rendered' : 'raw';
      await renderSourceViewer(els.sourceSelect.value, null);
    });

    els.genMode?.addEventListener('change', () => {
      const mode = String(els.genMode.value || '').trim().toLowerCase();
      applyModePreset(mode, { overwriteAdvanced: true });
      writeSettings(currentSettings());
    });

    (async function init() {
      await loadGenerationPresets();
      populateModeSelect();

      const saved = readSettings() || {};
      const savedMode = String(saved.mode || saved.generation_mode || '').trim().toLowerCase();
      const mode = generationPresetByKey.has(savedMode) ? savedMode : generationDefaultMode;
      if (els.genMode) els.genMode.value = mode;
      applyModePreset(mode, { overwriteAdvanced: true });
      applySettings(saved);

      applyUi(readUi());
      setupSourcesSplitter();
      populateSourceSelect();
      checkHealth();
      loadHistory();
    })();
  </script>
</body>
</html>
