<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Financial RAG</title>
  <style>
    :root{
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.08);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --border: rgba(255,255,255,0.12);
      --accent: #7c3aed;
      --accent2: #22c55e;
      --danger: #ef4444;
      --shadow: 0 18px 45px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(124,58,237,0.28), transparent 55%),
        radial-gradient(1100px 650px at 80% 20%, rgba(34,197,94,0.22), transparent 55%),
        radial-gradient(900px 500px at 50% 90%, rgba(59,130,246,0.20), transparent 55%),
        var(--bg);
      color: var(--text);
    }
    header {
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(14px);
      background: linear-gradient(to bottom, rgba(11,16,32,0.92), rgba(11,16,32,0.65));
      border-bottom: 1px solid var(--border);
    }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 1rem 1.25rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    .brand { display: flex; align-items: baseline; gap: 0.8rem; }
    h1 { margin: 0; font-size: 1.05rem; letter-spacing: 0.2px; }
    .subtitle { color: var(--muted); font-size: 0.9rem; }
    .actions { display:flex; gap: 0.5rem; align-items:center; flex-wrap: wrap; }
    main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1.25rem;
    }
    .grid {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 1rem;
      align-items: start;
    }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .panelHeader {
      padding: 0.9rem 1rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      background: rgba(255,255,255,0.03);
    }
    .panelHeader h2 { margin: 0; font-size: 0.95rem; }
    .panelBody { padding: 1rem; }
    .muted { color: var(--muted); }
    .row { display:flex; gap: 0.75rem; align-items: center; flex-wrap: wrap; }
    .spacer { flex: 1; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%;
      padding: 0.75rem 0.85rem;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      outline: none;
    }
    textarea { min-height: 110px; resize: vertical; }
    input::placeholder, textarea::placeholder { color: rgba(255,255,255,0.45); }
    .btn {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 0.55rem 0.8rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 650;
      letter-spacing: 0.2px;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }
    .btn.primary { background: linear-gradient(135deg, rgba(124,58,237,0.95), rgba(59,130,246,0.85)); border-color: rgba(124,58,237,0.25); }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.danger { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.35); }
    .btn.danger:hover { background: rgba(239,68,68,0.18); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .pill {
      font-size: 0.78rem;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      white-space: nowrap;
    }
    .historyList { max-height: 70vh; overflow: auto; }
    .historyItem {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
    }
    .historyItem:hover { background: rgba(255,255,255,0.06); }
    .historyItem.active { background: rgba(124,58,237,0.14); }
    .historyQ { font-weight: 650; font-size: 0.92rem; line-height: 1.25rem; }
    .historyMeta { margin-top: 0.3rem; font-size: 0.82rem; color: var(--muted); display:flex; gap: 0.5rem; flex-wrap: wrap; }
    .statusLine { font-size: 0.9rem; color: var(--muted); }
    .answer {
      white-space: pre-wrap;
      line-height: 1.45rem;
      font-size: 0.98rem;
    }
    .markdown p { margin: 0.55rem 0; }
    .markdown h1, .markdown h2, .markdown h3, .markdown h4, .markdown h5, .markdown h6 { margin: 0.8rem 0 0.4rem 0; }
    .markdown h1 { font-size: 1.25rem; }
    .markdown h2 { font-size: 1.15rem; }
    .markdown h3 { font-size: 1.05rem; }
    .markdown code { font-family: var(--mono); font-size: 0.9em; padding: 0.08rem 0.28rem; border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; background: rgba(0,0,0,0.25); }
    .markdown pre { font-family: var(--mono); font-size: 0.86rem; background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.10); border-radius: 12px; padding: 0.75rem; overflow: auto; }
    .markdown ul { margin: 0.5rem 0 0.5rem 1.25rem; }
    mark { background: rgba(34,197,94,0.22); color: var(--text); padding: 0.02rem 0.12rem; border-radius: 6px; }
    mark.active { outline: 2px solid rgba(34,197,94,0.85); background: rgba(34,197,94,0.30); }
    details {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      overflow: hidden;
    }
    summary {
      list-style: none;
      cursor: pointer;
      padding: 0.7rem 0.85rem;
      display:flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: space-between;
      user-select: none;
    }
    summary::-webkit-details-marker { display: none; }
    .chunkBody { padding: 0.85rem; border-top: 1px solid var(--border); }
    .chunkText {
      font-family: var(--mono);
      font-size: 0.86rem;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 0.75rem;
      overflow: auto;
      white-space: pre-wrap;
    }
    a { color: rgba(147,197,253,0.95); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .kv { display:grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    @media (max-width: 980px) { .kv { grid-template-columns: 1fr; } }
    .help {
      font-size: 0.86rem;
      color: var(--muted);
      line-height: 1.2rem;
    }
    .code { font-family: var(--mono); font-size: 0.86rem; }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">
        <h1>Financial RAG</h1>
        <div class="subtitle">Ask questions, inspect retrieved chunks, and open source docs.</div>
      </div>
      <div class="actions">
        <span class="pill" id="healthPill">checking /health…</span>
        <button class="btn" id="reloadHistoryBtn" title="Reload persisted history">Reload history</button>
        <button class="btn" id="exportHistoryBtn" title="Download history as JSON">Export</button>
        <button class="btn danger" id="clearHistoryBtn" title="Delete persisted server history">Clear history</button>
      </div>
    </div>
  </header>
  <main>
    <div class="grid">
      <section class="panel">
        <div class="panelHeader">
          <h2>History</h2>
          <span class="pill" id="historyCount">0</span>
        </div>
        <div class="panelBody" style="padding-bottom: 0.75rem;">
          <input id="historyFilter" type="text" placeholder="Filter by question text…" />
          <div class="help" style="margin-top: 0.6rem;">
            Persisted on the server at <span class="code" id="historyPath">(loading…)</span> and also cached in your browser.
          </div>
        </div>
        <div class="historyList" id="historyList"></div>
      </section>

      <section class="panel">
        <div class="panelHeader">
          <h2>Ask</h2>
          <div class="row">
            <span class="pill" id="activeEntryPill">no selection</span>
          </div>
        </div>
        <div class="panelBody">

          <form id="queryForm" style="margin-top: 1rem;">
            <label class="muted" for="question">Question</label>
            <textarea id="question" name="question" placeholder="e.g. Summarize the key risk factors mentioned in the latest filing for Company X."></textarea>

            <div class="kv" style="margin-top: 0.75rem;">
              <div>
                <label class="muted" for="topKRetrieve">top_k_retrieve</label>
                <input id="topKRetrieve" type="number" min="1" step="1" value="30" />
              </div>
              <div>
                <label class="muted" for="topKRerank">top_k_rerank</label>
                <input id="topKRerank" type="number" min="1" step="1" value="8" />
              </div>
              <div>
                <label class="muted" for="draftMaxTokens">draft_max_tokens</label>
                <input id="draftMaxTokens" type="number" min="1" step="1" value="65536" />
              </div>
              <div>
                <label class="muted" for="finalMaxTokens">final_max_tokens</label>
                <input id="finalMaxTokens" type="number" min="1" step="1" value="32768" />
              </div>
            </div>

            <div class="row" style="margin-top: 0.85rem;">
              <button class="btn primary" type="submit" id="queryBtn">Ask</button>
              <button class="btn" type="button" id="copyAnswerBtn" disabled>Copy answer</button>
              <button class="btn" type="button" id="copyDebugBtn" disabled>Copy debug</button>
              <div class="spacer"></div>
              <span class="statusLine" id="queryStatus"></span>
            </div>
          </form>

          <div id="answerBlock" style="display:none; margin-top: 1rem;">
            <div class="row" style="margin-bottom: 0.25rem;">
              <h3 style="margin: 0; font-size: 1rem;">Final answer</h3>
              <div class="spacer"></div>
              <span class="pill" id="chunkCountPill">0 chunks</span>
            </div>
            <div class="answer markdown" id="finalAnswer"></div>

            <div style="margin-top: 1rem;">
              <h3 style="margin: 0 0 0.5rem 0; font-size: 1rem;">Retrieved chunks</h3>
              <div class="help" style="margin-bottom: 0.6rem;">
                Use “Open source” to view the underlying PDF/Markdown. For local paths outside the allowlist, set
                <span class="code">SOURCE_ROOTS</span> on the server.
              </div>
              <div id="chunks"></div>
            </div>

            <div style="margin-top: 1rem;">
              <details id="sourceViewerDetails">
                <summary>
                  <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
                    <strong>Source viewer</strong>
                    <span class="pill" id="sourceCountPill">0 docs</span>
                    <span class="pill" id="sourceModePill">raw</span>
                  </div>
                  <div class="muted" style="font-size: 0.86rem;">toggle</div>
                </summary>
                <div class="chunkBody">
                  <div class="row" style="margin-bottom:0.6rem;">
                    <select id="sourceSelect" style="flex:1; min-width: 260px;"></select>
                    <button class="btn" type="button" id="sourceReloadBtn">Reload</button>
                    <button class="btn" type="button" id="sourceToggleModeBtn">Toggle rendered/raw</button>
                    <div class="spacer"></div>
                    <span class="statusLine" id="sourceStatus"></span>
                  </div>
                  <div class="help" style="margin-bottom:0.6rem;">
                    Best-effort highlighting by matching chunk text inside the source markdown. For non-markdown sources, use “Open source”.
                  </div>
                  <div class="chunkText" id="sourceContent" style="max-height: 52vh;"></div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);

    const els = {
      healthPill: $('healthPill'),
      reloadHistoryBtn: $('reloadHistoryBtn'),
      exportHistoryBtn: $('exportHistoryBtn'),
      clearHistoryBtn: $('clearHistoryBtn'),
      historyCount: $('historyCount'),
      historyPath: $('historyPath'),
      historyFilter: $('historyFilter'),
      historyList: $('historyList'),
      activeEntryPill: $('activeEntryPill'),

      queryForm: $('queryForm'),
      question: $('question'),
      topKRetrieve: $('topKRetrieve'),
      topKRerank: $('topKRerank'),
      draftMaxTokens: $('draftMaxTokens'),
      finalMaxTokens: $('finalMaxTokens'),
      queryBtn: $('queryBtn'),
      queryStatus: $('queryStatus'),

      answerBlock: $('answerBlock'),
      finalAnswer: $('finalAnswer'),
      chunks: $('chunks'),
      chunkCountPill: $('chunkCountPill'),

      copyAnswerBtn: $('copyAnswerBtn'),
      copyDebugBtn: $('copyDebugBtn'),

      sourceViewerDetails: $('sourceViewerDetails'),
      sourceCountPill: $('sourceCountPill'),
      sourceModePill: $('sourceModePill'),
      sourceSelect: $('sourceSelect'),
      sourceReloadBtn: $('sourceReloadBtn'),
      sourceToggleModeBtn: $('sourceToggleModeBtn'),
      sourceStatus: $('sourceStatus'),
      sourceContent: $('sourceContent'),
    };

    const LS_HISTORY = 'finrag_history_v1';
    const LS_SETTINGS = 'finrag_settings_v1';

    let historyItems = [];
    let activeEntry = null;
    let lastQueryResponse = null;
    let sourceMode = 'raw'; // 'raw' or 'rendered'
    let lastChunksBySource = new Map(); // source -> chunks[]
    let sourceCache = new Map(); // source -> {path, text}

    function safeText(s) {
      return String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function sanitizeHref(href) {
      const h = String(href || '').trim();
      if (!h) return '#';
      if (h.startsWith('http://') || h.startsWith('https://') || h.startsWith('/')) return h;
      return '#';
    }

    function mdInline(s) {
      // Input is raw text; returns safe HTML.
      let out = safeText(s);
      out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
      out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      out = out.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      out = out.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, href) => {
        const h = sanitizeHref(href);
        return `<a href="${h}" target="_blank" rel="noopener">${text}</a>`;
      });
      return out;
    }

    function renderMarkdown(md) {
      const lines = String(md ?? '').replace(/\r\n/g, '\n').split('\n');
      let html = '';
      let inCode = false;
      let inList = false;
      let codeBuf = '';
      const closeList = () => { if (inList) { html += '</ul>'; inList = false; } };
      const flushCode = () => {
        if (codeBuf) {
          html += `<pre><code>${safeText(codeBuf)}</code></pre>`;
          codeBuf = '';
        }
      };
      for (const line of lines) {
        const fence = line.match(/^```/);
        if (fence) {
          if (!inCode) {
            closeList();
            inCode = true;
            codeBuf = '';
          } else {
            inCode = false;
            flushCode();
          }
          continue;
        }
        if (inCode) {
          codeBuf += line + '\n';
          continue;
        }

        const heading = line.match(/^(#{1,6})\s+(.*)$/);
        if (heading) {
          closeList();
          const level = heading[1].length;
          html += `<h${level}>${mdInline(heading[2])}</h${level}>`;
          continue;
        }
        const li = line.match(/^\s*[-*]\s+(.*)$/);
        if (li) {
          if (!inList) { html += '<ul>'; inList = true; }
          html += `<li>${mdInline(li[1])}</li>`;
          continue;
        }

        if (!line.trim()) {
          closeList();
          html += '<br />';
          continue;
        }
        closeList();
        html += `<p>${mdInline(line)}</p>`;
      }
      if (inCode) flushCode();
      if (inList) html += '</ul>';
      return html;
    }

    function isMarkdownSource(source) {
      const s = String(source || '').trim().toLowerCase();
      return s.endsWith('.md') || s.endsWith('.markdown') || s.endsWith('.txt');
    }

    function buildChunksBySource(chunks) {
      const map = new Map();
      (Array.isArray(chunks) ? chunks : []).forEach((c) => {
        const src = String(c?.source || '').trim();
        if (!src) return;
        if (!map.has(src)) map.set(src, []);
        map.get(src).push(c);
      });
      return map;
    }

    function findBestSpan(text, snippet) {
      const hay = String(text ?? '');
      let needle = String(snippet ?? '').trim();
      if (!hay || !needle) return null;

      if (needle.length > 240) needle = needle.slice(0, 240);

      let idx = hay.indexOf(needle);
      if (idx >= 0) return { start: idx, end: idx + needle.length };

      // Try whitespace-insensitive match using a token regex.
      const tokens = needle.split(/\s+/).filter(Boolean).slice(0, 30);
      if (tokens.length >= 6) {
        const escapeRe = (t) => String(t).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const pattern = tokens.map(escapeRe).join('\\s+');
        const re = new RegExp(pattern, 'm');
        const m = re.exec(hay);
        if (m && typeof m.index === 'number') return { start: m.index, end: m.index + m[0].length };
      }

      // Fall back to searching a shorter prefix.
      if (needle.length > 80) {
        const short = needle.slice(0, 80);
        idx = hay.indexOf(short);
        if (idx >= 0) return { start: idx, end: idx + short.length };
      }

      return null;
    }

    function renderTextWithMarks(text, spans, activeChunkId) {
      const src = String(text ?? '');
      const safeSpans = (Array.isArray(spans) ? spans : [])
        .filter(s => s && Number.isFinite(s.start) && Number.isFinite(s.end) && s.start >= 0 && s.end > s.start)
        .sort((a, b) => a.start - b.start);

      const merged = [];
      let lastEnd = -1;
      for (const s of safeSpans) {
        if (s.start < lastEnd) continue;
        merged.push(s);
        lastEnd = s.end;
      }

      let out = '';
      let pos = 0;
      for (const s of merged) {
        out += safeText(src.slice(pos, s.start));
        const chunkId = String(s.chunk_id || '');
        const cls = chunkId && activeChunkId && chunkId === activeChunkId ? 'active' : '';
        out += `<mark class="${cls}" data-chunk-id="${safeText(chunkId)}">${safeText(src.slice(s.start, s.end))}</mark>`;
        pos = s.end;
      }
      out += safeText(src.slice(pos));
      return out;
    }

    async function loadSourceText(source) {
      const src = String(source || '').trim();
      if (!src) throw new Error('Missing source');
      if (sourceCache.has(src)) return sourceCache.get(src);
      const res = await fetch('/source_text?path=' + encodeURIComponent(src));
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      sourceCache.set(src, data);
      return data;
    }

    function populateSourceSelect() {
      const sources = Array.from(lastChunksBySource.keys()).filter(isMarkdownSource);
      els.sourceSelect.innerHTML = '';
      sources.forEach((src) => {
        const opt = document.createElement('option');
        const count = (lastChunksBySource.get(src) || []).length;
        opt.value = src;
        opt.textContent = `${src} (${count})`;
        els.sourceSelect.appendChild(opt);
      });
      els.sourceCountPill.textContent = `${sources.length} docs`;
      if (!sources.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No markdown sources in current results';
        els.sourceSelect.appendChild(opt);
      }
    }

    async function renderSourceViewer(source, activeChunkId) {
      const src = String(source || '').trim();
      if (!src || !isMarkdownSource(src)) {
        els.sourceContent.innerHTML = '<div class="muted">Select a markdown source to view it here.</div>';
        return;
      }

      els.sourceStatus.textContent = 'Loading…';
      try {
        const data = await loadSourceText(src);
        const text = String(data.text ?? '');
        const chunks = lastChunksBySource.get(src) || [];

        const spans = [];
        for (const c of chunks) {
          const chunkId = String(c?.chunk_id || '');
          const snippet = String(c?.text || c?.preview || '').trim();
          if (!chunkId || !snippet) continue;
          const span = findBestSpan(text, snippet);
          if (!span) continue;
          spans.push({ ...span, chunk_id: chunkId });
        }

        if (sourceMode === 'rendered') {
          els.sourceModePill.textContent = 'rendered';
          els.sourceContent.classList.add('markdown');
          els.sourceContent.innerHTML = renderMarkdown(text);
          els.sourceStatus.textContent = 'Rendered (highlighting is raw-only)';
        } else {
          els.sourceModePill.textContent = 'raw';
          els.sourceContent.classList.remove('markdown');
          els.sourceContent.innerHTML = renderTextWithMarks(text, spans, activeChunkId);
          els.sourceStatus.textContent = spans.length ? `Highlighted ${spans.length} matches` : 'No matches found';
          if (activeChunkId) {
            const m = els.sourceContent.querySelector(`mark[data-chunk-id="${CSS.escape(activeChunkId)}"]`);
            if (m) m.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }
        }
      } catch (e) {
        console.error(e);
        els.sourceStatus.textContent = 'Error';
        els.sourceContent.innerHTML = `<div class="muted">Failed to load source: ${safeText(e)}</div>`;
      }
    }

    function fmtDate(iso) {
      if (!iso) return 'unknown time';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return String(iso);
      return d.toLocaleString();
    }

    function readLocalHistory() {
      try {
        const raw = localStorage.getItem(LS_HISTORY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function writeLocalHistory(items) {
      try { localStorage.setItem(LS_HISTORY, JSON.stringify(items)); } catch {}
    }

    function readSettings() {
      try {
        const raw = localStorage.getItem(LS_SETTINGS);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function writeSettings(settings) {
      try { localStorage.setItem(LS_SETTINGS, JSON.stringify(settings)); } catch {}
    }

    function currentSettings() {
      const toInt = (v, fallback) => {
        const n = Number(v);
        return Number.isFinite(n) && n > 0 ? Math.floor(n) : fallback;
      };
      return {
        top_k_retrieve: toInt(els.topKRetrieve.value, 30),
        top_k_rerank: toInt(els.topKRerank.value, 8),
        draft_max_tokens: toInt(els.draftMaxTokens.value, 65536),
        final_max_tokens: toInt(els.finalMaxTokens.value, 32768),
      };
    }

    function applySettings(s) {
      if (!s) return;
      if (s.top_k_retrieve) els.topKRetrieve.value = s.top_k_retrieve;
      if (s.top_k_rerank) els.topKRerank.value = s.top_k_rerank;
      if (s.draft_max_tokens) els.draftMaxTokens.value = s.draft_max_tokens;
      if (s.final_max_tokens) els.finalMaxTokens.value = s.final_max_tokens;
    }

    async function checkHealth() {
      try {
        const res = await fetch('/health');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        els.healthPill.textContent = 'healthy';
        els.healthPill.style.borderColor = 'rgba(34,197,94,0.45)';
        els.healthPill.style.color = 'rgba(167,243,208,0.95)';
      } catch {
        els.healthPill.textContent = 'health check failed';
        els.healthPill.style.borderColor = 'rgba(239,68,68,0.45)';
        els.healthPill.style.color = 'rgba(254,202,202,0.95)';
      }
    }

    function renderHistory() {
      const q = (els.historyFilter.value || '').trim().toLowerCase();
      const filtered = q
        ? historyItems.filter(it => (it?.request?.question || '').toLowerCase().includes(q))
        : historyItems;

      els.historyCount.textContent = String(filtered.length);
      els.historyList.innerHTML = '';

      if (!filtered.length) {
        const div = document.createElement('div');
        div.className = 'panelBody muted';
        div.textContent = q ? 'No matches.' : 'No history yet. Ask a question to create entries.';
        els.historyList.appendChild(div);
        return;
      }

      filtered.forEach((it) => {
        const div = document.createElement('div');
        div.className = 'historyItem' + ((activeEntry && it.id === activeEntry.id) ? ' active' : '');
        const question = it?.request?.question || '(missing question)';
        const when = fmtDate(it?.created_at);
        const chunks = it?.response?.top_chunks?.length ?? 0;
        div.innerHTML = `
          <div class="historyQ">${safeText(question)}</div>
          <div class="historyMeta">
            <span>${safeText(when)}</span>
            <span class="pill">${chunks} chunks</span>
          </div>
        `;
        div.addEventListener('click', () => {
          activeEntry = it;
          els.activeEntryPill.textContent = it.id ? `selected: ${it.id.slice(0, 8)}` : 'selected';
          renderHistory();
          showEntry(it);
        });
        els.historyList.appendChild(div);
      });
    }

    function sourceHref(source) {
      const s = String(source || '').trim();
      if (!s) return null;
      if (s.startsWith('http://') || s.startsWith('https://')) return s;
      return '/source?path=' + encodeURIComponent(s);
    }

    function renderChunks(chunks) {
      const list = Array.isArray(chunks) ? chunks : [];
      els.chunkCountPill.textContent = `${list.length} chunks`;
      els.chunks.innerHTML = '';
      if (!list.length) {
        els.chunks.innerHTML = '<div class="muted">No chunks returned.</div>';
        return;
      }

      list.forEach((c, idx) => {
        const headings = Array.isArray(c.headings) && c.headings.length ? c.headings.join(' › ') : '';
        const href = sourceHref(c.source);
        const score = (typeof c.score === 'number') ? c.score.toFixed(3) : String(c.score ?? '');
        const preview = safeText((c.preview ?? '') + (c.preview ? '…' : ''));
        const chunkText = String(c.text ?? '');
        const contextText = String(c.context ?? '').trim();
        const src = String(c.source || '').trim();
        const canViewInApp = isMarkdownSource(src);

        const details = document.createElement('details');
        details.style.marginBottom = '0.6rem';
        details.innerHTML = `
          <summary>
            <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
              <span class="pill">#${idx + 1}</span>
              <span class="pill">score=${safeText(score)}</span>
              <span class="pill">doc=${safeText(c.doc_id ?? '')}</span>
              <span class="pill">chunk=${safeText(c.chunk_id ?? '')}</span>
            </div>
            <div class="muted" style="font-size: 0.86rem;">toggle</div>
          </summary>
          <div class="chunkBody">
            ${headings ? `<div style="margin-bottom:0.35rem;"><strong>${safeText(headings)}</strong></div>` : ''}
            <div class="muted" style="margin-bottom:0.55rem;">${preview}</div>
            <div class="row" style="margin-bottom: 0.6rem;">
              ${href ? `<a href="${href}" target="_blank" rel="noopener">Open source</a>` : '<span class="muted">No source link</span>'}
              <button class="btn" type="button" data-action="view-in-app" ${canViewInApp ? '' : 'disabled'}>View in app</button>
              <span class="pill">${canViewInApp ? 'markdown' : 'non-markdown'}</span>
            </div>
            ${contextText ? `<div style="margin-bottom:0.55rem;"><div class="muted" style="margin-bottom:0.2rem;">Context</div><div class="chunkText">${safeText(contextText)}</div></div>` : ''}
            ${chunkText ? `<div><div class="muted" style="margin-bottom:0.2rem;">Chunk text</div><div class="chunkText">${safeText(chunkText)}</div></div>` : '<div class="muted">No chunk text included.</div>'}
          </div>
        `;
        details.addEventListener('toggle', () => {
          if (details.open && canViewInApp) {
            // Mildly helpful: open the source viewer when you expand a chunk.
            els.sourceViewerDetails.open = true;
            els.sourceSelect.value = src;
            renderSourceViewer(src, String(c.chunk_id || ''));
          }
        });
        const btn = details.querySelector('button[data-action="view-in-app"]');
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            els.sourceViewerDetails.open = true;
            els.sourceSelect.value = src;
            renderSourceViewer(src, String(c.chunk_id || ''));
          });
        }
        els.chunks.appendChild(details);
      });
    }

    function showEntry(it) {
      if (!it) return;
      const res = it.response || {};
      els.answerBlock.style.display = 'block';
      els.finalAnswer.innerHTML = renderMarkdown(String(res.final_answer ?? ''));
      const chunks = res.top_chunks || [];
      renderChunks(chunks);
      lastChunksBySource = buildChunksBySource(chunks);
      populateSourceSelect();
      lastQueryResponse = res;
      els.copyAnswerBtn.disabled = !String(res.final_answer ?? '').trim();
      els.copyDebugBtn.disabled = false;
    }

    async function loadHistoryFromServer() {
      const res = await fetch('/history?limit=200');
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();
      const items = Array.isArray(data.items) ? data.items : [];
      historyItems = items;
      if (data.path) els.historyPath.textContent = data.path;
      writeLocalHistory(items);
      renderHistory();
      return items;
    }

    async function loadHistory() {
      // Fast path: render local cache immediately, then refresh from server.
      historyItems = readLocalHistory();
      renderHistory();
      try {
        await loadHistoryFromServer();
      } catch (e) {
        console.warn('Failed to load /history; using local cache.', e);
      }
    }

    async function clearHistory() {
      if (!confirm('Delete server history? This removes the JSONL file.')) return;
      els.clearHistoryBtn.disabled = true;
      try {
        const res = await fetch('/history', { method: 'DELETE' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        historyItems = [];
        activeEntry = null;
        writeLocalHistory([]);
        renderHistory();
        els.activeEntryPill.textContent = 'no selection';
        els.answerBlock.style.display = 'none';
      } catch (e) {
        alert('Failed to clear history: ' + e);
      } finally {
        els.clearHistoryBtn.disabled = false;
      }
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function exportHistory() {
      try {
        const res = await fetch('/history?limit=2000');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        const items = Array.isArray(data.items) ? data.items : [];
        downloadJson('finrag_history.json', items);
      } catch (e) {
        alert('Failed to export history: ' + e);
      }
    }

    async function doQuery(question) {
      const settings = currentSettings();
      writeSettings(settings);

      els.queryBtn.disabled = true;
      els.queryStatus.textContent = 'Retrieving & generating…';
      els.copyAnswerBtn.disabled = true;
      els.copyDebugBtn.disabled = true;
      try {
        const res = await fetch('/query', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question, ...settings }),
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        lastQueryResponse = data;
        els.answerBlock.style.display = 'block';
        els.finalAnswer.innerHTML = renderMarkdown(String(data.final_answer ?? ''));
        const chunks = data.top_chunks || [];
        renderChunks(chunks);
        lastChunksBySource = buildChunksBySource(chunks);
        populateSourceSelect();
        els.queryStatus.textContent = '';
        els.copyAnswerBtn.disabled = !String(data.final_answer ?? '').trim();
        els.copyDebugBtn.disabled = false;

        // Refresh persisted history so the new entry shows up with its server timestamp/id.
        await loadHistoryFromServer();
      } catch (e) {
        console.error(e);
        els.queryStatus.textContent = 'Error: ' + e;
      } finally {
        els.queryBtn.disabled = false;
      }
    }

    els.queryForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const q = (els.question.value || '').trim();
      if (!q) {
        els.queryStatus.textContent = 'Please enter a question.';
        return;
      }
      await doQuery(q);
    });

    els.historyFilter.addEventListener('input', () => renderHistory());
    els.reloadHistoryBtn.addEventListener('click', () => loadHistory());
    els.clearHistoryBtn.addEventListener('click', () => clearHistory());
    els.exportHistoryBtn.addEventListener('click', () => exportHistory());

    els.copyAnswerBtn.addEventListener('click', async () => {
      const text = String(lastQueryResponse?.final_answer ?? '');
      try { await navigator.clipboard.writeText(text); } catch { alert('Clipboard write failed'); }
    });

    els.copyDebugBtn.addEventListener('click', async () => {
      const payload = {
        question: String(els.question.value || ''),
        settings: currentSettings(),
        response: lastQueryResponse,
        selected_history_entry: activeEntry,
      };
      try { await navigator.clipboard.writeText(JSON.stringify(payload, null, 2)); } catch { alert('Clipboard write failed'); }
    });

    els.sourceSelect.addEventListener('change', async () => {
      await renderSourceViewer(els.sourceSelect.value, null);
    });
    els.sourceReloadBtn.addEventListener('click', async () => {
      const src = els.sourceSelect.value;
      sourceCache.delete(src);
      await renderSourceViewer(src, null);
    });
    els.sourceToggleModeBtn.addEventListener('click', async () => {
      sourceMode = (sourceMode === 'raw') ? 'rendered' : 'raw';
      await renderSourceViewer(els.sourceSelect.value, null);
    });

    (function init() {
      applySettings(readSettings());
      checkHealth();
      loadHistory();
    })();
  </script>
</body>
</html>
